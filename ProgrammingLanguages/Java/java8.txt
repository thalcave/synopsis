----------------------------------------------------------------------------------------------------------------------------------
Java 8 Introduction

1. Default methods for interfaces
- add non-abstract method implementations to interfaces by utilizing the default keyword

  interface Formula
  {
        default double sqrt(int a) { return Math.sqrt(a); }
  }

abstract class vs. interface in Java 8:
* abstract classes allow non-static and non-final fields and allow methods to be public, private, or protected
while interfaces fields are inherently public, static, and final, and all interface methods are inherently public.

* if a class implements two interfaces having a default method with the same name, the result will
be a compilation error


2. Functional interfaces

Prior to Java8, devs were using Single Abstract Method (SAM) interfaces: interface with only one method,
which were used to create anonymous inner classes:
      e.g.: Runnable, Comparator, Callable
      
Java8: SAM are called Functional interfaces:
* must contain exactly one abstract method declaration
* can have any number of default methods

       @FunctionalInterface --> compilation error if another abstract method is added
       public interface SimpleFuncInterface {
              public void doWork();
       }

       // function taking FunctionalInterface argument 
       public static void carryOutWork(SimpleFuncInterface sfi)
       {
           sfi.doWork();
       }

       // lambda
       carryOutWork(
                () -> System.out.println("Do work in lambda exp impl...")
           );

       //old-style
       carryOutWork(
                new SimpleFuncInterface() {
                       @Override
                       public void doWork()
                       {
                           System.out.println("Do work in SimpleFun impl...");
                       }
                 }
          );


Some functional interfaces:
Supplier<T> : supplier of results
    BooleanSupplier, IntSupplier, DoubleSupplier etc.

Function<T,R>: a function that accepts one argument and produces a result
    BiFunction<T, U, R>
       - functional interface representing a function which accepts 2 arguments and returns a result
       - two-arity specialization of Function


3. Lambda expressions

Lambda expressions in Java is usual written using syntax:
    (argument) -> (body).

Examples:
    () -> 42
 
    Collections.sort(names, (String a, String b) -> {
           return b.compareTo(a);
    });

    Collections.sort(names, (String a, String b) -> b.compareTo(a));

    // one line method bodies can skip both {} and return
    Collections.sort(names, (a, b) -> b.compareTo(a));


* For anonymous class ‘this’ keyword resolves to anonymous class, whereas for lambda
expression ‘this’ keyword resolves to enclosing class where lambda is written.
* Java compiler compiles lambda expressions and convert them into private method of the class

Assign lambda to a variable:
        final BiFunction<Integer, String, Integer> mapperFn = (k, v) -> v == null ? -1 : v + 10;
        final IntSupplier intSupplier = () -> 42
        final BiFunction<String, String, boolean> compareFn = (a, b) -> b.compareTo(a)

        @FunctionalInterface
        interface Converter<F, T> {
                T convert(F from);
            }

       Converter<String, Integer> converter = (from) -> Integer.valueOf(from);

4. Method and Constructor References
Java 8 enables you to pass references of methods or constructors via the :: keyword
     Integer::valueOf

Example:     
     class Person;

     interface PersonFactory<P extends Person> {
         P create(String firstName, String lastName);
     }

     PersonFactory<Person> personFactory = Person::new;
     Person person = personFactory.create("Peter", "Parker");

We create a reference to the Person constructor via Person::new.
The Java compiler automatically chooses the right constructor by matching the signature of PersonFactory.create.


5. Lambda scopes

* you can access final variables (or implicitly final) from the local outer scope 
The following code does not compile:
    int num = 1;
    Converter<Integer, String> stringConverter =
        (from) -> String.valueOf(from + num);
    num = 3;   // 'num' is not implicitly final

* you can access instance fields and static variables from lambda

6. Built-in Functional Interfaces

* Predicates
- boolean-valued functions of one argument
- Predicate<String>

* Functions
- accept one argument and produce a result
- default methods can be used to chain multiple functions together (compose, andThen):
    Function<String, Integer> toInteger = Integer::valueOf;
    Function<String, String> backToString = toInteger.andThen(String::valueOf);
    
* Suppliers
- produce a result of a given generic type
    Supplier<Person> personSupplier = Person::new;
    personSupplier.get();   // new Person

* Consumers
- operations to be performed on a single input argument.

* Comparators
* Optionals
- a simple container for a value which may be null or non-null


7. Streams

stream = sequence of elements on which one or more operations can be performed
       intermediate (return the stream itself) or terminal (return result) operations
sequential or parallel stream

List<String> stringCollection = new ArrayList<>();

Filter: accepts a predicate to filter all elements of the stream
* intermediate operation, which enables us to call another stream operation (forEach) on the result
- ForEach accepts a consumer to be executed for each element in the filtered stream
- ForEach is a terminal operation. It`s void, so we cannot call another stream operation
    stringCollection
      .stream()
      .filter((s) -> s.startsWith("a"))
      .forEach(System.out::println);


Sorted: an intermediate operation which returns a sorted view of the stream (without touching the ordering of the collection)
        stringCollection
            .stream()
            .sorted()
            .filter((s) -> s.startsWith("a"))
            .forEach(System.out::println);


Map: an intermediate operation which converts each element into another object via the given function
        stringCollection
            .stream()
            .map(String::toUpperCase)
            .sorted((a, b) -> b.compareTo(a))
            .forEach(System.out::println);

Match: various terminal operations, used to check if a predicate is true
anyMatch(), allMatch(), noneMatch()

            boolean allStartsWithA =
                    stringCollection
                    .stream()
                    .allMatch((s) -> s.startsWith("a"));

Count: terminal operation returning the number of elements in the stream as a long
       long startsWithB =
            stringCollection
            .stream()
            .filter((s) -> s.startsWith("b"))
            .count();

Reduce: terminal operation performs a reduction on the elements of the stream with the given function.
The result is an Optional holding the reduced value.

    Optional<String> reduced =
                     stringCollection
                     .stream()
                     .sorted()
                     .reduce((s1, s2) -> s1 + "#" + s2);


8. Parallel Streams
Operations on sequential streams are performed on a single thread,
while operations on parallel streams are performed concurrent on multiple threads.

Parallel Sort
         long count = values.parallelStream().sorted().count();


9. Map

* Maps don`t support streams
* new methods: putIfAbsent(), forEach(), getOrDefault(),

10. Date API
Java 8 contains a brand new date and time API under the package java.time.

Clock
* Clock provides access to the current date and time.
* may be used instead of System.currentTimeMillis()

11. Annotations

Annotations = a form of metadata that provides data about a program
- is not part of the program itself
- annotations have no direct effect on the operation of the code they annotate

Uses:
* Information for the compiler — Annotations can be used by the compiler to detect errors or suppress warnings.
* Compile-time and deployment-time processing — Software tools can process annotation information to generate code, XML files, and so forth.
* Runtime processing — Some annotations are available to be examined at runtime.


In previous versions of Java, developers could write annotations only on declarations.
With Java 8, annotations can now also be written on any use of a type such as types in declarations, generics, and casts:
     @Encrypted String data;
     List<@NonNull String> strings;
     myGraph = (@Immutable Graph) tmpGraph;

Annotations in Java 8 are repeatable:
* one of the limitations of annotation usage was the fact that the same annotation cannot be declared more than once at the same location
* Java8: It allows the same annotation to be repeated several times in place it is declared.

         @Schedule(dayOfMonth="last")
         @Schedule(dayOfWeek="Fri", hour="23")
         public void doPeriodicCleanup() { ... }

Repeating annotations are stored in a container annotation that is automatically generated by the Java compiler.
In order for the compiler to do this, two declarations are required in your code.
a) Declare a Repeatable Annotation Type

           @Repeatable(Schedules.class)
           public @interface Schedule {
             String dayOfMonth() default "first";
             String dayOfWeek() default "Mon";
             int hour() default 12;
           }

b) Declare the Containing Annotation Type (that must have a value element with an array type):

           public @interface Schedules {
                  Schedule[] value();
           }


Example:
         // a holder of Filter annotations
         @Target( ElementType.TYPE )
         @Retention( RetentionPolicy.RUNTIME )
         public @interface Filters {
                Filter[] value();
         }


         // annotation class Filter: repeatable Filters
         @Target( ElementType.TYPE )
         @Retention( RetentionPolicy.RUNTIME )
         @Repeatable( Filters.class )
         public @interface Filter {
                String value();
         };



         @Filter( "filter1" )
         @Filter( "filter2" )
         public interface Filterable {       
                }



     
----------------------------------------------------------------------------------------------------------------------------------
Java 8 Concurrency Tutorial

1. Concurrency: Threads and Executors

a) Threads
task = code executed by the thread
* specified by implementing Runnable

  Runnable task = () -> {
           // do work
  };

  task.run();   // execute it on the main thread

  Thread thread = new Thread(task);
  thread.start();


b) Executors
ExecutorService = higher level replacement for working with threads directly.
* are capable of running asynchronous tasks (Runnable, Callable)
* typically manage a pool of threads, so we don`t have to create new threads manually.

  // use an executor with a thread pool of size one.
  ExecutorService executor = Executors.newSingleThreadExecutor();
  executor.submit(
        () -> {
            String threadName = Thread.currentThread().getName();
            System.out.println("Hello " + threadName);
        }
    );
* Executors have to be stopped explicitly, otherwise they keep listening for new tasks.
- shutdown() waits for currently running tasks to finish
- shutdownNow() interrupts all running tasks and shut the executor down immediately.

    try {
        System.out.println("attempt to shutdown executor");
        executor.shutdown();
        executor.awaitTermination(5, TimeUnit.SECONDS);
    }
    catch (InterruptedException e) {
        System.err.println("tasks interrupted");
    }
    finally {
        if (!executor.isTerminated()) {
            System.err.println("cancel non-finished tasks");
        }
        executor.shutdownNow();
        System.out.println("shutdown finished");
    }


c) Callables and Futures

Callable = functional interface that returns a value
 * supported by Executors (just like the Runnable)

   Callable<Integer> task = () -> {
       try {
           TimeUnit.SECONDS.sleep(1);
           return 123;
       }
       catch (InterruptedException e) {
           throw new IllegalStateException("task interrupted", e);
       }
   };

Future = result of an async computation
- special result used to retrieve the actual result at a later point in time

Since Executor.submit() doesn`t wait until the task completes, the executor service cannot return
the result of the callable directly. Instead the executor returns a special result of type Future,
which can be used to retrieve the actual result at a later point in time.

    ExecutorService executor = Executors.newFixedThreadPool(1);
    Future<Integer> future = executor.submit(task);
    System.out.println("future done? " + future.isDone());

    // this will block the current thread until the callable completes
    Integer result = future.get();

    System.out.println("future done? " + future.isDone());
    System.out.print("result: " + result);



Every non-terminated future will throw exceptions if you shutdown the executor:
    executor.shutdownNow();
    future.get(); // will throw exception
      
         
d) Timeouts
* specify maximum wait time
* throws TimeoutException
    future.get(10, TimeUnit.SECONDS);

e) InvokeAll
* Executors support batch submitting of multiple callables at once via invokeAll()
- accepts a collection of Callables
- returns a list of Futures

    ExecutorService executor = Executors.newWorkStealingPool();
    List<Callable<String>> callables = Arrays.asList(
                                                 () -> "task1",
                                                 () -> "task2",
                                                 () -> "task3");

    executor.invokeAll(callables)
        .stream()
        .map(future -> {
            try {
                return future.get();
            }
            catch (Exception e) {
                throw new IllegalStateException(e);
            }
        })
        .forEach(System.out::println);

f) InvokeAny
* Instead of returning future objects this method blocks until the first callable terminates and returns the result of that callable.  


g) Scheduled Executors

ScheduledExecutorService = capable of scheduling tasks to run either periodically or once after a certain amount of time has elapsed.
      
      ScheduledExecutorService executor = Executors.newScheduledThreadPool(1);
      Runnable task = () -> System.out.println("Scheduling: " + System.nanoTime());
      // run the task after an initial delay of 3 seconds
      ScheduledFuture<?> future = executor.schedule(task, 3, TimeUnit.SECONDS);

      // retrieve the remaining delay
      long remainingDelay = future.getDelay(TimeUnit.MILLISECONDS);

      int initialDelay = 0;
      int period = 1;
      // execute tasks at a fixed time rate (once every second)
      executor.scheduleAtFixedRate(task, initialDelay, period, TimeUnit.SECONDS);

* scheduleAtFixedRate() doesn`t take into account the actual duration of the task.
* scheduleWithFixedDelay() works just like the counterpart described above;
the difference is that the wait time period applies between the end of a task and the start of the next task


h) CompletableFuture
* a Future (result for async operation) that can be explicitly completed
* allows to complete a future when an event happened

#### Creation:
* create a CompletableFuture using its constructor:
    public CompletableFuture<String> ask() {
        final CompletableFuture<String> future = new CompletableFuture<>();
        //...
        return future;
    }
- client will block here:
     CompletableFuture completableFuture = ask();
     completableFuture.get(); // will block
- unblock all clients:
     future.complete("a string")

* create it using factory methods, specifying the mode (sync or async) and its task or process:
- CompletableFuture.runAsync() = takes a Runnable -> returns a CompletableFuture<Void> (because Runnable doesn`t return anything)
- CompletableFuture.supplyAsync() = takes a Supplier -> returns a CompletableFuture<T>
        final CompletableFuture<String> future = CompletableFuture.supplyAsync(new Supplier<String>() {
                @Override
                public String get() {
                //...long running...
                return "42";
             }
        }, executor);

        or:
        final CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> longRunningTask(params), executor);

!!! supplyAsync() returns a new CompletableFuture that is asynchronously completed by a task running in the ForkJoinPool.commonPool()
with the value obtained by calling the given Supplier.

     
#### Getting results:
* Using the get() method:
        // wait forever until the CompletableFuture is completed or cancelled
        cf.get();
* Using the getNow(fallback) method:
        // if the result is not yet present, fallback is returned
        cf.getNow("fallback")
* Using the get(long amount, TimeUnit unit)
        // waits x time units and tries to return the computed value if available; if not, TimeoutException is thrown
        cf.get(3, TimeUnit.SECONDS)


#### Completing ad-hoc

* create a Completable that is not gonna end:
           CompletableFuture completableFutureToBeCompleted2 = CompletableFuture.supplyAsync( ( ) -> {
                             for( int i = 0; i < 10; i-- )
                             {
                                System.out.println( "i " + i );
                             }
                             return 10;
                  } );

* create a new CompletableFuture that is going to complete the first one:
  CompletableFuture completor = CompletableFuture.supplyAsync( ( ) -> {
	            System.out.println( "completing the other" );
                    completableFutureToBeCompleted2.complete( 222 );
	            return 10;
        } );

* retrieve the results:
  System.out.println( completor.get() );
  System.out.println( completableFutureToBeCompleted2.get() );

* CompletableFuture.complete() can only be called once, subsequent invocations are ignored
* CompletableFuture.completeExceptionally(ex) - signal failure by passing some exception
         - unlocks all waiting clients, but this time throwing an exception from get()

#### Joining
It is possible to join different CompletableFuture and use its results in future calculations using the methods thenApply() and thenCompose():
* run this function on a result, when it arrives
   // from String -> Integer -> Double
   CompletableFuture<String> f1 = //...
   CompletableFuture<Integer> f2 = f1.thenApply(Integer::parseInt);
   CompletableFuture<Double> f3 = f2.thenApply(r -> r * r * Math.PI);
* these transformations are neither executed immediately nor blocking;
  they are simply remembered and when original f1() completes they are executed for you.

Running code on completion (thenAccept/thenRun)

Combining two CompletableFuture together

   CompletableFuture completableFutureBigCompute = CompletableFuture.supplyAsync( ( ) -> {
                     // big computation
	             return "10";
                     } );

   CompletableFuture thenCompose = completableFutureBigCompute.thenCompose(CombiningCompletableFutures::continueWithVeryImportantThing);

   CompletableFuture<CompletableFuture> thenApply = completableFutureBigCompute.thenApply(CombiningCompletableFutures::continueWithSomethingElse);

   System.out.println( "thenCompose " + thenCompose.get() );
   System.out.println( "thenApply " + thenApply.get() ); // is already completed
   System.out.println( "thenApply " + thenApply.isDone() ); // is already completed

   CompletableFuture thenCompose2 = completableFutureBigCompute.thenCompose(CombiningCompletableFutures::continueWithVeryImportantThing );

   // difference between compose and apply: thenCompose uses the value of the source
   System.out.println( "thenCompose2 " + thenCompose2.get() ); 

####
#### 
         

2. Synchronization and Locks

a) Synchronized
Internally Java uses a so called monitor also known as monitor lock or intrinsic lock in order to manage synchronization.

    synchronized void incrementSync() {
        count = count + 1;
    }

The synchronized keyword is also available as a block statement:
    void incrementSync() {
        synchronized (this) {
            count = count + 1;
        }
    }


b) Locks

Locks support various methods for finer grained lock control thus are more expressive than implicit monitors.


----------------------------------------------------------------------------------------------------------------------------------
Java8 Conversion functions/idioms


1. Collection of sets to set:
        final Set<String> topicsToDelete = new HashSet<>();
        setsCollection.forEach(topicsToDelete::addAll);

2. Construct a map from a collection:
        Map<String, ContactRelationship> customDisplayNames = collection
            .stream()
            .collect(Collectors.toMap(
                    ContactRelationship::getTargetEndUser,
                    contactRealtionship -> contactRealtionship
            ));


3. Extract List from another List:
        List<String> userIdsAsStrings = userIdList.stream().map(UserId::toString).collect(Collectors.toList());

4. List to Set:
        Set<Foo> foo = new HashSet<Foo>(myList);

5. Set to List:
       mainList.addAll(set);
