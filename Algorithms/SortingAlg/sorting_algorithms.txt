stable sorting algorithms = maintain the relative order of records with equal keys (i.e., values)
	e.g if we are sorting pairs (i,j) only after (i), ...

1) Merge sort:
- O(n log n) comparison based sorting algorithm
- divide and conquer (recursively breaking down a problem into two or more sub-problems of the same (or related) type,
		      until these become simple enough to be solved directly.
		      The solutions to the sub-problems are then combined to give a solution to the original problem.)

merge sort:
1. If the list is of length 0 or 1, then it is already sorted. Otherwise:
	2. Divide the unsorted list into two sublists of about half the size.
	3. Sort each sublist recursively by re-applying merge sort.
	4. Merge the two sublists back into one sorted list

two main ideas to improve runtime:
- A small list will take fewer steps to sort than a large list.
- Fewer steps are required to construct a sorted list from two sorted lists than two unsorted lists

- useful for sorting data on disk that is too large to fit entirely into primary memory

mergeSort()
{
	if (array.size() <= 1)
		return array
		
	middle = array.size()/2
	left = mergeSort(left_array)
	right = mergeSort(rightArray)
	
	return merge2Sorted(left, right)
}


Best case: O(n logn)
Avg  case: O(n logn)
Worst case:O(n logn)


2) Quicksort
Best case: O(n logn)
Avg  case: O(n logn)
Worst case:O(n^2)


Algorithm:
* pick pivot from list
* smaller elems go to minlist, greater elems go to maxlist
* recursively apply the steps above for minlist and maxlist
	concatenate(quicksort(minlist), pivot, quicksort(maxlist))

3) counting sort:
* sorting a collection of objects according to keys that are small integers
O(n+k): n - input size
	k - number of keys

space: O(n+k)


4) Radix sort
 * sorts data with integer keys by grouping keys by the individual digits which share the same significant position and value. 
 sort after last digit
 sort after second to last digit...
 
 
 time:  O(kN)
 space: O(k+N) 
 
 
5) Bucket (bin) sort: partition an array in a number of buckets, sort them and merge them
Steps:
1. set up array of initially empty buckets
2. scatter: go over initial array, putting each object in its bucket
3. sort each non-empty bucket
4. gather: visit the buckets in order and put all elements back into the original array

The most common variant of bucket sort operates on a list of n numeric inputs between zero and some maximum value M and divides the value range into n buckets each of size M/n.




 
---------------------------------------------------------------------------------
Selection algorithm
* suitable for finding the kth smallest number in an array/list (e.g min, max, median)

a. sort the array (O(nlogn)) and select desired element
- efficient when many selections are needed
- lower time when using counting/radix sort

b. Partial selection sort:
* sort only the first k elements (using selection sort): find the minimum value and move it to the beginning, repeating on the remaining list until we have accumulated k elements, and then return the kth element
* complexity: O(kn) --> efficient if k is small

c. Quickselect:
Solution: uses the same overall approach as quicksort, choosing one element as a pivot and partitioning the data in two based on the pivot, accordingly as less than or greater than the pivot. 
 * However, instead of recursing into both sides, as in quicksort, quickselect only recurses into one side â€“ the side with the element it is searching for. 
 * This reduces the average complexity from O(n log n) (in quicksort) to O(n) (in quickselect)
 


