-------------------------------------------------------------------------
P1 2 sorted arrays, A and B; A has enough space at the end to hold B
merge B in A in sorted order

- merge A and B from the back

void merge(vector A, vector B)
{
	cpos = A.size() - 1;	
	idxA = index of last element from A
	idxB = B.size() - 1;
	
	while (idxA>=0 && idxB>=0)
	{
		if (A[idxA] > B[idxB])
		{
			A[cpos] = B[idxB];
			--idxB;
		}
		else
		{
			A[cpos] = A[idxA];
			--idxA;
		}
		--cpos;
	}
	
	while (idxB >=0)
	{
		A[cpos] = B[idxB];
		--cpos;
		--idxB;
	}
}

-------------------------------------------------------------------------
P2 sort an array of strings so that all anagrams are next to each other

Solution:
implement a comparator which sorts the strings and then compares them

struct CompareStrings
{
	bool operator()(std::string const& s1, std::string const& s2)
	{
		return std::sort(s1.begin(), s1.end()) < std::sort(s2.begin(), s2.end());
	}
}

-------------------------------------------------------------------------
P3 sorted array of strings interspersed with empty strings; find a given strings

Solution: do binary search, if empty string is found, move to next one, until a valid string is found

-------------------------------------------------------------------------
P4 matrix, each row/column is sorted, find an elemen in it


-------------------------------------------------------------------------
P5 2GB file, one string per line; which algorithm would you use to sort it?

Solution:
- merge sort takes O(n logn) and O(n) space complexity, so it's not useful
Use external sorting:
* divide file in 10 regions
* sort each region in memory, write it
* merge regions:

-------------------------------------------------------------------------
P6 Find and maintain the median value as new values are generated

Solution: use 2 heaps: a Max and a Min one, with following restraints:

1. numbers from Max-heap are smaller than numbers from Min-heaps
2. size(Max-heap) is equal to or 1 more than size(Min-heap):
	if N is even --> size(Max-heap) = size(Min-heap) = N/2
	if N is odd --> size(Max-heap) = N/2 + 1 size(Min-heap) = N/2

2 methods: insert(elem)	and getMedian()
insert():
- insert to Max-heap
- if total_no is even before insertion --> OK
- if total_no is odd before insertion --> Max-heap has N+2 elems and Min-heap has N elem --> Restraint 2 is violated:
	pop elem from Max-heap
	insert popped elem in Min-Heap
- if inserted elem is less than MinHeap->root --> OK
- if inserted elem is bigger than MinHeap->root:
	exchange these elements: pop root of min-heap, insert it into max-heap
				 pop root of max-heap, insert it into min-heap
