
I/O scheduler = the interface between the generic block layer and the low-level device drivers

block layer = provides functions that are utilized by the file systems and the virtual memory manager to
submit I/O requests to block devices.
device drivers = consume the requests transformed by scheduler and forward them to the actual device controllers

I/O batch = set of read or write requests


knowledge : of workload, filesystem, I/O hardware

Functions:
- merging: merges requests to reduce the number of them
- sorting: sorts the merged requests, to minimize the movement of read/write head

------------------------------
Deadline
	operates on five I/O queues
basic idea: aggressively re-order requests to improve I/O performance while ensuring that no I/O request is being starved

pre-request deadline:
	- each I/O request gets associated with a deadline ( enqueue phase )
	- is inserted into Q1 (organized by starting block), Q2 (FIFO org. by deadline), Q3 or Q4 (read and write FIFOS)
	Q5 - requests that are to be handed off to the device driver (dispatch queue)
	
	during dequeue --> requests are moved from one of the four Q to Q5
	next --> hand over the head of Q5 to device driver
	
scheduler's goal = to ensure that each read request is processed by its deadline without actually starving the queued-up write requests

the goal of minimizing disk seek : moving a larger batch of requests from the sort list (sector sorted)
and balancing it with a controlled number of requests from FIFO list

summary:
	all read requests are satisfied within a period of time
	write requests don't have deadlines
	
	
---------------------------------
Anticipatory

- a delay so that a thread that just finished its I/O request is allowed to submit a new request

if the disk drive just operated on a read request, there are good chances that another read request is in the pipeline
hence, it's worth to wait

smaller seeks but decreased disk utilization
The AS scheduler excels on small systems which have limited I/O configurations

it's default


---------------------------------
Completely Fair Queuing Scheduler

- fair allocation of I/O bandwidth among all initiators of I/O requests

uses n internal I/O queues, a single I/O dispatch queue;
enqueue: the PID of currently running process (I/O request producer) is used to select an internal queue;
dequeue: round-robin based scan through non-empty queues

works well when all I/O processes generate requests at the same rate


---------------------------------
No-op scheduler

minimal I/O scheduler that performs basic merging and sorting functionalities
main usage: non disk-based block devices( memory devices), specialized software or hardware that incorporates their own I/O scheduling
and cache functionality --> minimal assistance from the kernel

TCQ - tag command queuing; 
	a feature introduced in the SCSI-2 specification that permits each initiator to issue commands 
	accompanied by instructions for how the target should handle the command; 
	the initiator can either request the command to be executed at the first available opportunity, 
	in the order in which the command was received, or at a time deemed appropriate by the target.
RAID, TCQ capable disk drives - outperforms the other 3 schedulers
in presence of advanced disk controllers, use noop to minimize CPU overhead



****************************************************************************

mixed workloads = workloads comprised of concurrent I/O requests generated by different processes that exhibit different types of access patterns and methods

- the AS provides the best performance for sequential read requests executed on single disk hardware configurations;
- for moderate hardware configurations (RAID systems with 2-5 disks), the deadline and CFQ schedulers perform better than the others; 
- the noop scheduler is particularly suitable for large RAID (e.g., RAID-0 with tens of disks) systems consisting of SCSI drives that have their
	own scheduling and caching mechanisms

the AS and deadline scheduler provide substantially good performance in single disk and
2-5 disk configurations; sometimes the AS performs
better than the deadline scheduler and
vice versa



Sequential Read/Write
- the drive is receiving a stream of requests to read and write data blocks. 
	The addresses of the data blocks are sequentially increasing

Single CPU - Single Disk Setup

sequential read - AS outperformed the other 3
sequential write - AS on ext3, noop on xfs


8-way RAID-5 setup
write - CFQ
read - 

-----------------------
Tuning for anticipatory
nr_requests = I/O operations on fly 
	from 128 to 2560
	
nr_request = 2560	
antic_expire = 0	- disables anticipatory portion of the scheduler
read_batch_expire = 1000
read_expire = 500
write_batch_expire = 250
write_expire = 5000	
on a raid 5, it's an improvement	
	
	
CFQ reacted positively

Sequential read performance
 single disk setup, AS implementation provides optimal throughput performance
 	
